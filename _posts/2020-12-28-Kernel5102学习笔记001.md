---
layout:     post
title:      Kernel 5.10.2
subtitle:   Kernel 学习笔记
date:       2020-12-28
author:     Jeff
header-img: img/bg_wolf.jpg
catalog: true
tags:
    - Kernel
    - Code
    - 
---

>Kernel 学习笔记

# 内核常用到的宏：
### \_\_read\_mostly:


 		##宏定义在 arch/arm/include/asm/cache.h
 	#define __read_mostly __attribute__((__section__(".data..read_mostly"))) 
 		##实例：
 	bool early_boot_irqs_disabled __read_mostly;
 		##用来标记 early_boot_irqs_disabled 这个变量经常被读取，如果平台支持缓存，会把这个变量放到cache中
 
 
###  \_\_initdata:
		##宏定义在include/linux/init.h
	#define __initdata    __section(.init.data)
	#define __initconst    __constsection(.init.rodata)
		##实例：
	char __initdata boot_command_line[COMMAND_LINE_SIZE];
		##同上面__read_mostly一样，是用来把这个变量绑定在某个区里面

![](https://jeffnoteimgs.oss-cn-shanghai.aliyuncs.com/imgs20201228163641.png)

### \_\_init、\_\_exit：
	#define __init        __section(.init.text) __cold notrace
		##实例：
	static int __init forward_init_module(void)
		##用于标记函数，放在.init.text section，标记为初始化的函数,表明该函数供在初始化期间使用。在模块装载之后，模块装载就会将初始化函数扔掉。这样可以将该函数占用的内存释放出来。
		
		#define __exit          __section(".exit.text") __exitused __cold notrace
		##实例：
		static void __exit forward_uninit_module(void)
		
### \_\_cold:
	#define __cold   __attribute__((__cold__))
		##__cold告诉编译器这个函数很可能不被执行到
		
### notrace:
	#define notrace __attribute__((no_instrument_function))
		##notrace如同GCC的-finstrument-functions（） 参数的作用是在程序中加入hook，让它在每次进入和退出函数的时候分别调用这个函数

### noinline:
	#define  noinline   __attribute__((noinline))  
		##阻止该函数被内联

### \_\_setup 和 early_param:
	unsigned int reset_devices;
	EXPORT_SYMBOL(reset_devices);
	static int __init set_reset_devices(char *str)
	{
		reset_devices = 1;
		return 1;
	}
	__setup("reset_devices", set_reset_devices);
	
		##__setup，这个函数就理解为：启动时候如果有接收reset_devices参数，那么就调用set_reset_devices方法
		##与__setup相对应的还有一个叫做early_param。这两个宏函数的功能一样，区别就在于early_param定义的参数比__setup更早

# 源码：
---
>												进入源码部分

---
走完引导阶段，进入内核入口函数start_kernel()：(在init/main.c中)

```cpp
asmlinkage __visible void __init __no_sanitize_address start_kernel(void){	char *command_line;	char *after_dashes;	set_task_stack_end_magic(&init_task);	smp_setup_processor_id();	debug_objects_early_init();	cgroup_init_early();	local_irq_disable();	early_boot_irqs_disabled = true;	/*	 * Interrupts are still disabled. Do necessary setups, then	 * enable them.	 */	boot_cpu_init();	page_address_init();	pr_notice("%s", linux_banner);	early_security_init();	setup_arch(&command_line);	setup_boot_config(command_line);	setup_command_line(command_line);	setup_nr_cpu_ids();	setup_per_cpu_areas();	smp_prepare_boot_cpu();	/* arch-specific boot-cpu hooks */	boot_cpu_hotplug_init();	build_all_zonelists(NULL);	page_alloc_init();	pr_notice("Kernel command line: %s\n", saved_command_line);	/* parameters may set static keys */	jump_label_init();	parse_early_param();	after_dashes = parse_args("Booting kernel",				  static_command_line, __start___param,				  __stop___param - __start___param,				  -1, -1, NULL, &unknown_bootoption);	if (!IS_ERR_OR_NULL(after_dashes))		parse_args("Setting init args", after_dashes, NULL, 0, -1, -1,			   NULL, set_init_arg);	if (extra_init_args)		parse_args("Setting extra init args", extra_init_args,			   NULL, 0, -1, -1, NULL, set_init_arg);	/*	 * These use large bootmem allocations and must precede	 * kmem_cache_init()	 */	setup_log_buf(0);	vfs_caches_init_early();	sort_main_extable();	trap_init();	mm_init();	ftrace_init();	/* trace_printk can be enabled here */	early_trace_init();	/*	 * Set up the scheduler prior starting any interrupts (such as the	 * timer interrupt). Full topology setup happens at smp_init()	 * time - but meanwhile we still have a functioning scheduler.	 */	sched_init();	/*	 * Disable preemption - early bootup scheduling is extremely	 * fragile until we cpu_idle() for the first time.	 */	preempt_disable();	if (WARN(!irqs_disabled(),		 "Interrupts were enabled *very* early, fixing it\n"))		local_irq_disable();	radix_tree_init();	/*	 * Set up housekeeping before setting up workqueues to allow the unbound	 * workqueue to take non-housekeeping into account.	 */	housekeeping_init();	/*	 * Allow workqueue creation and work item queueing/cancelling	 * early.  Work item execution depends on kthreads and starts after	 * workqueue_init().	 */	workqueue_init_early();	rcu_init();	/* Trace events are available after this */	trace_init();	if (initcall_debug)		initcall_debug_enable();	context_tracking_init();	/* init some links before init_ISA_irqs() */	early_irq_init();	init_IRQ();	tick_init();	rcu_init_nohz();	init_timers();	hrtimers_init();	softirq_init();	timekeeping_init();	/*	 * For best initial stack canary entropy, prepare it after:	 * - setup_arch() for any UEFI RNG entropy and boot cmdline access	 * - timekeeping_init() for ktime entropy used in rand_initialize()	 * - rand_initialize() to get any arch-specific entropy like RDRAND	 * - add_latent_entropy() to get any latent entropy	 * - adding command line entropy	 */	rand_initialize();	add_latent_entropy();	add_device_randomness(command_line, strlen(command_line));	boot_init_stack_canary();	time_init();	perf_event_init();	profile_init();	call_function_init();	WARN(!irqs_disabled(), "Interrupts were enabled early\n");	early_boot_irqs_disabled = false;	local_irq_enable();	kmem_cache_init_late();	/*	 * HACK ALERT! This is early. We're enabling the console before	 * we've done PCI setups etc, and console_init() must be aware of	 * this. But we do want output early, in case something goes wrong.	 */	console_init();	if (panic_later)		panic("Too many boot %s vars at `%s'", panic_later,		      panic_param);	lockdep_init();	/*	 * Need to run this when irqs are enabled, because it wants	 * to self-test [hard/soft]-irqs on/off lock inversion bugs	 * too:	 */	locking_selftest();	/*	 * This needs to be called before any devices perform DMA	 * operations that might use the SWIOTLB bounce buffers. It will	 * mark the bounce buffers as decrypted so that their usage will	 * not cause "plain-text" data to be decrypted when accessed.	 */	mem_encrypt_init();#ifdef CONFIG_BLK_DEV_INITRD	if (initrd_start && !initrd_below_start_ok &&	    page_to_pfn(virt_to_page((void *)initrd_start)) < min_low_pfn) {		pr_crit("initrd overwritten (0x%08lx < 0x%08lx) - disabling it.\n",		    page_to_pfn(virt_to_page((void *)initrd_start)),		    min_low_pfn);		initrd_start = 0;	}#endif	setup_per_cpu_pageset();	numa_policy_init();	acpi_early_init();	if (late_time_init)		late_time_init();	sched_clock_init();	calibrate_delay();	pid_idr_init();	anon_vma_init();#ifdef CONFIG_X86	if (efi_enabled(EFI_RUNTIME_SERVICES))		efi_enter_virtual_mode();#endif	thread_stack_cache_init();	cred_init();	fork_init();	proc_caches_init();	uts_ns_init();	buffer_init();	key_init();	security_init();	dbg_late_init();	vfs_caches_init();	pagecache_init();	signals_init();	seq_file_init();	proc_root_init();	nsfs_init();	cpuset_init();	cgroup_init();	taskstats_init_early();	delayacct_init();	poking_init();	check_bugs();	acpi_subsystem_init();	arch_post_acpi_subsys_init();	sfi_init_late();	kcsan_init();	/* Do the rest non-__init'ed, we're now alive */	arch_call_rest_init();	prevent_tail_call_optimization();}
```
